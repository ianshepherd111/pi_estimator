program mcpi

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!			Variable type declarations
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

implicit none

!define magnitude and precision of variables
integer, parameter :: dp = SELECTED_REAL_KIND(15,307)
integer, parameter :: large = SELECTED_INT_KIND(18)

!pi
real (dp), parameter  :: pi=3.1415926535897932384626433



!loop indices and a counter
integer (large) :: N, i, M, j, count

!number of ignored random numbers
integer (large), allocatable, dimension (:) :: discard

!seed of random number generator
integer (large), allocatable, dimension (:) :: seed

!user input bounds
integer (large) :: N_lower, N_upper, M_lower, M_upper, discard_lower, discard_upper, seed_lower, seed_upper

!input request string
character (len=70) :: N_string, M_string, discard_string, seed_string

!user input for the sphere or circle choice
integer :: shape_type

!sphere/circle user input check variable
integer :: io_err



!sphere or circle pi formula factor
real (dp) :: multiplier

!coodinates x, y & z
real (dp) :: x, y, z

!current estimate for pi, after 'n'-many Monte Carlo steps
real (dp) :: running_pi_est

!standard deviation of the running_pi_est dataset, after 'n'-many Monte Carlo steps
real (dp) :: running_pi_stdev

!Welford algorithm variables, (t = mean), (used to calculate the running standard deviation, running_pi_stdev)
real (dp) :: t, t_prev, s

!Factor that determines when running_pi_stdev is written out to a file (depends on an if statement)
integer (large) :: modulo_factor

!pi value estimate generated by each Monte Carlo calculation
real (dp), allocatable, dimension (:) :: final_pi_est


!statistical calculation variables for the final_pi_est dataset of pi values
real (dp) :: pi_mean, pi_stdev


!program running time variables
real (dp) :: start_time, stop_time
real (dp), allocatable, dimension (:) :: time_taken



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!					Variable assignment
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



N_string = 'Please input the number of Monte Carlo steps'
M_string = 'Please input the number of times to evaluate pi'
discard_string = 'Please input the number of random numbers to be discarded'
seed_string = 'Please input a seed for the random number generator'

N_lower = 1
M_lower = 1
discard_lower = 0
!this value is explained in the random number generator function
seed_lower = -2147428875


N_upper = 1000000000000_large
M_upper = 10000_large
discard_upper = 100000000000_large
seed_upper = -1


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!					Program start - Read and check user input at runtime
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


! Request user input for choice of sphere or circle, then name file appropriately and set shape_type and multiplier variables
write (6,*) 'Input the relevant value below to calculate pi using either a circle or sphere'
write (6,*) 'Sphere : 1 '
write (6,*) 'Circle : Any other input '

read (5,*,iostat=io_err) shape_type

if 	(  (io_err == 0) .and. (shape_type == 1)  ) then
  write (6,1050) 'Running calculation for a sphere...'
  open (10,file='sphere.dat',status='unknown')

else
  shape_type = 0
  write (6,1050) 'Running calculation for a circle...'
  open (10,file='circle.dat',status='unknown')
end if

1050 format (/, a, /)

multiplier = real(   ( 4 + (2*shape_type) )  , dp )




! Subroutine that reads and checks user input value is valid:
call get_user_input ( N , N_string , N_lower , N_upper )					! 'N' = number of MC moves to calculate pi
call get_user_input ( M , M_string , M_lower , M_upper )					! 'M' = number of times to repeat the calculation of pi


!allocate arrays
allocate( final_pi_est(M), seed(M), discard(M), time_taken(M) )



write (6,1055) 'Please enter the seed value(s) for these calculations'
1055 format ( /, a )

!get seed M times
do j = 1, M

  write (6,1060) 'Calculation number: ', j
  1060 format (/, a, I0)
  call get_user_input ( seed(j) , seed_string , seed_lower , seed_upper )		! 'seed' = random number generator seed


  discard(j) = 0		! 'discard' = number of random numbers to discard
  !!! alternatively can set discard manually:
  !call get_user_input ( discard(j) , discard_string , discard_lower , discard_upper )
  !!!


end do


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!					Calculation of Pi (M times)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

write (6,1070) 'Calculating...'
1070 format ( /, a, /)


do j = 1, M

  !reset loop variables
  count = 0
  t_prev = real ( 0, dp )
  s = real ( 0, dp )
  modulo_factor = 1

  !write parameters and table headers before the outputted data
  write (10,1100) 'N', N, 'discard', discard(j), 'seed', seed(j)
  1100 format (a, 10x, I0, /, a, 4x, I0, /, a, 6x, I0)

  if (N > 1) then
    write (10,1300) 'i', 'log10(i)', 'Running Standard Deviation'
    1300 format (21x, a, 8x, a, 11x, a)
  end if


  call cpu_time (start_time)

  !intiate random number generator and then throwaway 'discard'-many random numbers
  x = ran1 (seed(j))

  if (discard(j) > 0) then

    do i = 1, discard(j)

      x = ran1 (1_large)

    end do

  end if



  do i = 1,N

    x = ran1(1_large)
    y = ran1(1_large)
    !ran1 returns a value between 0 and 1

	!Circle
    if (shape_type /= 1) then
      !count the number of points that fall inside the arc of the circle
      if (		( (x*x)+(y*y) )	<= real (1, dp)	) then
        count = count + 1
      end if

    !Sphere
    else
      z = ran1(1_large)
      !count the number of points that fall inside the radius of the sphere
      if (		( (x*x)+(y*y)+(z*z) ) <= real(1, dp)	) then
        count = count + 1
      end if

    end if


    !evaluate pi for this number of points
    running_pi_est = multiplier*(real(count, dp)/real(i, dp))

    !Welford algorithm - note: t = mean of running_pi_est dataset
    t = t_prev + (  (running_pi_est - t_prev) / ( real (i, dp) )   )
    s = s + (running_pi_est - t_prev)*(running_pi_est - t)
    t_prev = t

    !nested if statements to select i = 2,3,4,...,98,99,100,110,120,...,180,190,200,210,...,980,990,1000,1100,1200,etc.
    if (	(i > 1) .and. ( modulo (i,modulo_factor) == 0)   	) then

        !Standard deviation evaluation for 'i' number of points
        running_pi_stdev = sqrt( s / (real((i-1), dp) ) )

        write (10,*) i, log10(real(i, dp)), running_pi_stdev

        !at powers of 10 (except 10), multiply modulo_factor by 10
        if ( modulo  ( i , (100*modulo_factor)  ) == 0) then
                modulo_factor = 10 * modulo_factor
        end if

    end if


  end do
  !End of N loop


  !if not already written out by the above loop, write out the final standard deviation
  if  ( modulo  ( N , modulo_factor ) /= 0) then
    write (10,*) N, log10(real(N, dp)), running_pi_stdev
  end if

  !calculate a final value for pi from the 'count', and the total number of MC moves
  final_pi_est(j) = multiplier *(	(real(count, dp))	/	(real(N, dp))	)



  write (10,*) ''
  write (10,*) 'Estimate of Pi',  final_pi_est(j)

  if ( N > 1) then
    write (10,*) 'Final Standard Deviation', running_pi_stdev
  end if

  write (10, *) ''


  write (6,1400) 'Calculation number:', j, 'Seed:', seed(j)
  1400 format ( /, a, 2x, I0, 4x, a, 2x, I0 )
  write (6,*) 'Estimate of Pi',  final_pi_est(j)

  call cpu_time(stop_time)
  time_taken(j) = stop_time - start_time

  write (6,*) 'Time taken:', time_taken(j), "seconds"



end do
!End of M loop




!Calculate the standard deviation of the data set and the mean
pi_mean = (     sum(final_pi_est) / real(M, dp)     )

write (10,*) 'Mean of estimates',pi_mean
write (6,*) ''
write (6,*) 'Mean of estimates',pi_mean

if ( M > 1 ) then
  pi_stdev = sqrt(     sum((final_pi_est-pi_mean)**2)   /  (real(M-1, dp))     )
  write (10,*) 'Standard Deviation of estimates', pi_stdev
  write (6,*) 'Standard Deviation of estimates', pi_stdev
end if

close (10)

write (6,*) 'Total time taken:', sum(time_taken), "seconds"

deallocate ( final_pi_est, seed, discard, time_taken)


contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!			Subroutine - user input checker
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine get_user_input ( user_input , var_info_string , lower_bound , upper_bound )

  implicit none
  integer (large), intent (inout) :: user_input
  character (70), intent (in) :: var_info_string
  integer (large), intent (in) :: lower_bound, upper_bound
  integer :: io_err

  !request and then read in user input
  write (6,100)  var_info_string, '(enter an integer between ', lower_bound, ' and ', upper_bound, ')'
  100 format (/, 1x, a, /, 1x, a, I0, a, I0, a)
  read (5,*,iostat=io_err) user_input

  !continue asking for new user input until 'user_input' is an integer greater than lower_bound and smaller than upper_bound
  do while  (   (io_err /= 0)  .or.   (user_input < lower_bound)  .or.   (user_input > upper_bound)  )

    if (io_err == 53) then
      !data-out-of-range/overflow error
      write (6,150) 'This value is too large, please enter another number'
      150 format ( /, 1x, a, /)

    else if (io_err /= 0) then
      write (6,150) 'This value is not recognised as an integer, please enter another number'

    else if (user_input > upper_bound) then
      write (6,200) 'This integer is greater than: ', upper_bound, 'Please enter a smaller value'
      200 format (/, 1x, a, I0, /, 1x, a, /)

    else
      write (6,200) 'This integer is less than: ', lower_bound, 'Please enter a larger value'

    end if

    write (6,100)  var_info_string, '(enter an integer between ', lower_bound, ' and ', upper_bound, ')'
    read (5,*,iostat=io_err) user_input


  end do

end subroutine get_user_input

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!			Function - Random number generator
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

function ran1(idum)

  integer :: j, ix1,ix2,ix3
  integer (large) :: idum
  real (dp) :: ran1, rm1,rm2, r(100)

  integer, parameter :: m1=259200, m2=134456, m3=243000, ia1=7141, ia2=8121, ia3=4561, ic1=54773, ic2=28411, ic3=51349 !
  save r,ix1,ix2,ix3


  rm2 = (real (1, dp) )  /  (real (m2, dp) )
  rm1 = (real (1, dp) )  /  (real (m1, dp) )


  !if statement executed when a seed (a negative integer) is provided as the argument of the function
  if (idum < 0  ) then

     ix1=mod(ic1-idum,m1)
     ! largest (ic1-idum) can be without overflow is  -(2,147,483,647), assuming that this is the default maximum
     ! so idum_min <  -(2,147,483,647) + 54773 - 1
     ! idum_min < -2,147,428,876  ; hence setting seed_lower to -2147428875 will always result in an acceptable value for idum

     ix1=mod(ia1*ix1+ic1,m1)
     ix2=mod(ix1,m2)
     ix1=mod(ia1*ix1+ic1,m1)
     ix3=mod(ix1,m3)

     !populate an array with "random" numbers made using the above variables
     do j=1,97
        ix1=mod(ia1*ix1+ic1,m1)
        ix2=mod(ia2*ix2+ic2,m2)
        r(j)=(real(ix1, dp)+real(ix2, dp)*rm2)*rm1
     end do

  end if

  !when not given a seed as an argument, return a "random" number r(j) and replace the value of r(j) with a new value
  ix1=mod(ia1*ix1+ic1,m1)
  ix2=mod(ia2*ix2+ic2,m2)
  ix3=mod(ia3*ix3+ic3,m3)

  j=1+(97*ix3)/m3
  ran1=r(j)
  r(j)=(real(ix1, dp)+real(ix2, dp)*rm2)*rm1

  return

end function ran1


end program mcpi
